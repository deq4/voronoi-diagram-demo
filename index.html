<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="algorithm.js"></script>
    <title>Fortune algorithm demo</title>
</head>
<body>
    <canvas width="1000" height="1000"></canvas>
    <table>
        <thead>
            <tr>
                <th colspan="3">Sites</th>
            </tr>
            <tr>
                <th>x</th>
                <th>y</th>
            </tr>
        </thead>
        <tbody id="site-table-body">
        </tbody>
        <tfoot>
            <tr>
                <td><input id="site-add-x"></td>
                <td><input id="site-add-y"></td>
                <td><button id="site-add-button">+</button></td>
            </tr>
        </tfoot>
    </table>
    <div id="canvas-controls">
        <label>
            X offset
            <input type="number" id="x_off" step="50" value="10">
        </label>
        <label>
            Y offset
            <input type="number" id="y_off" step="50" value="10">
        </label>
        <label>
            Scale
            <input type="number" id="scale" step="0.2" value="1" min="0.2">
        </label>
    </div>
    <div>
        <button id="step-button">Step</button>
        <button id="animate-button">Animate</button>
    </div>

    <template id="site-template-row">
        <tr>
            <td></td>
            <td></td>
            <td><button>-</button></td>
        </tr>
    </template>

    <style>
        body {
            display: flex;
        }

        div, table {
            margin-left: 20px;
        }

        div {
            display: flex;
            flex-direction: column;
        }

        div > * {
            margin: 10px;
        }

        canvas {
            width: 95vmin;
            height: 95vmin;
            align-self: center;
            border: 1px solid;
        }

        table {
            display: block;
        }

        td {
            text-align: right;
        }

        td input {
            width: 100px;
            text-align: right;
        }

        td button {
            width: 40px;
            border: 1px solid black;
        }
    </style>
    <script>
        const ALGO_SCALE = 50;

        function convertCoords(coords) {
            return {x: coords.x * ALGO_SCALE, y: coords.y * ALGO_SCALE};
        }

        function getRayBorderIntersection(startPoint, rayDirection, border) {
            let x, y;
            if (rayDirection.x !== 0) {
                x = rayDirection.x > 0 ? border.right : border.left;
                y = startPoint.y + (x - startPoint.x ) * rayDirection.y / rayDirection.x;
            } else {
                y = rayDirection.y > 0 ? border.bottom : border.top;
                x = startPoint.x;
            }
            return {x, y};
        }

        function getQuardraticSplineMidPointParam(lowPoint, p1, p2) {
            const a = (p1.y - p2.y);
            if (a === 0) {
                return {x: 2 * lowPoint.x - (p1.x + p2.x) / 2, y: 2 * lowPoint.y - p1.y};
            }
            const D = (lowPoint.y - p1.y) * (lowPoint.y - p2.y);
            let t;
            if (p1.x <= lowPoint.x && lowPoint.x <= p2.x) {
                t = (lowPoint.y - p2.y - Math.sqrt(D)) / a;
            } else {
                t = (lowPoint.y - p2.y + Math.sqrt(D)) / a;
            }
            const y = (lowPoint.y - t * p1.y) / (1-t);
            const x = (lowPoint.x - t*t * p1.x - (1-t)*(1-t) * p2.x) / (2*t*(1-t));
            return {x, y};
        }

        function drawAxes(drawingParams) {
            ctx.arc(0, 0, 2 / drawingParams.scale, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(drawingParams.border.left, 0);
            ctx.lineTo(drawingParams.border.right, 0);
            ctx.moveTo(0, drawingParams.border.top);
            ctx.lineTo(0, drawingParams.border.bottom);
            ctx.stroke();
        }

        function drawCircle(x, y, style, size) {
            ctx.save();
            ctx.fillStyle = style;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }

        function drawParabola(lowPoint, p1, p2) {
            const cp = getQuardraticSplineMidPointParam(lowPoint, p1, p2);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.quadraticCurveTo(cp.x, cp.y, p2.x, p2.y);
            ctx.stroke();
        }

        function clamp(x, lo, hi) {
            return Math.min(Math.max(x, lo), hi);
        }

        function drawParabolas(state, drawingParams, yScanLine) {
            const beachLine = state.beachLine;

            const minYSite = state.firstSite;
            if (beachLine.length === 0 && (minYSite === null || yScanLine <= minYSite.y)) {
                return;
            }

            for (let i = -1; i < beachLine.length; ++i) {
                let lX, rX;
                if (i !== -1) {
                    lX = clamp(getXFromVertex(beachLine[i], yScanLine),
                        drawingParams.border.left / ALGO_SCALE, drawingParams.border.right / ALGO_SCALE);
                } else {
                    lX = drawingParams.border.left / ALGO_SCALE;
                }
                if (i !== beachLine.length - 1) {
                    rX = clamp(getXFromVertex(beachLine[i+1], yScanLine),
                        drawingParams.border.left / ALGO_SCALE, drawingParams.border.right / ALGO_SCALE);
                } else {
                    rX = drawingParams.border.right / ALGO_SCALE;
                }
                if (lX >= rX) {
                    continue;
                }
                const site = i !== -1 ? beachLine[i].rParabolaSite :
                    beachLine.length !== 0 ? beachLine[i+1].lParabolaSite : minYSite;
                if (lX === site.x) {
                    lX -= 1e-6;
                }
                if (rX === site.x) {
                    rX += 1e-6;
                }
                const lP = convertCoords({x: lX, y: calcParabolaY(site, yScanLine, lX)});
                const rP = convertCoords({x: rX, y: calcParabolaY(site, yScanLine, rX)});
                const lowP = convertCoords({x: site.x, y: (site.y + yScanLine) / 2});
                drawParabola(lowP, lP, rP);
            }
        }

        function drawDiagram(sites, state, drawingParams) {
            const diagram = state.diagram;
            for (site of sites) {
                const coords = convertCoords(site);
                drawCircle(coords.x, coords.y, "black", 5 / drawingParams.scale);
            }

            for (vertex of diagram.vertices) {
                const coords = convertCoords(vertex);
                drawCircle(coords.x, coords.y, "blue", 5 / drawingParams.scale);
            }

            ctx.save();
            ctx.strokeStyle = "green";
            
            for (const edge of diagram.edges) {
                for (const ray of edge) {
                    const startCoords = convertCoords(ray.rayStart);
                    let endCoords;
                    if (ray.segmentEnd) {
                        endCoords = convertCoords(ray.segmentEnd);
                    } else {
                        const rayDirection = getRayDirection(ray);
                        endCoords = getRayBorderIntersection(startCoords, rayDirection, drawingParams.border);
                    }

                    ctx.beginPath();
                    ctx.moveTo(startCoords.x, startCoords.y === -Infinity ? drawingParams.border.top : startCoords.y);
                    ctx.lineTo(endCoords.x, endCoords.y);
                    ctx.stroke();
                }
            }
            ctx.restore();

            drawParabolas(state, drawingParams, yScanLine);
        }

        const addSiteButton = document.getElementById("site-add-button");
        const addSiteX = document.getElementById("site-add-x");
        const addSiteY = document.getElementById("site-add-y");
        const rowTemlate = document.getElementById("site-template-row");
        const sitesRows = document.getElementById("site-table-body");
        const removeSiteListener = ev => {
            const row = ev.target.parentElement.parentElement;
            row.remove();

            runAlgo();
        };
        const addSiteRow = (x, y) => {
            const row = rowTemlate.content.firstElementChild.cloneNode(true);
            row.children[0].innerText = x;
            row.children[1].innerText = y;
            row.children[2].firstElementChild.addEventListener("click", removeSiteListener);
            sitesRows.appendChild(row);
        };
        addSiteButton.addEventListener("click", ev => {
            addSiteRow(addSiteX.value, addSiteY.value);

            runAlgo();
        });

        const readSites = () => {
            let sites = [];
            for (const siteRow of sitesRows.children) {
                const x = parseFloat(siteRow.children[0].textContent);
                const y = parseFloat(siteRow.children[1].textContent);
                sites.push({x, y});
            }
            return sites;
        };

        let sites, diagram, state;
        let yScanLine = -Infinity;
        let animationRunning = false;

        function drawingStep() {
            animationRunning = false;
            if (yScanLine == -Infinity) {
                state = init(sites);
            }

            if (state.queue.length === 0) {
                yScanLine = -Infinity;
                return;
            }

            yScanLine = state.queue[0][0] + 1e-3;
            while (state.queue.length > 0 && state.queue[0][0] < yScanLine) {
                step(state);
            }
        }
        document.getElementById("step-button").addEventListener("click", drawingStep);

        function animate() {
            if (state.queue.length === 0) {
                state = init(sites);
                yScanLine = state.queue[0][0] + 1e-3;
            }
            animationRunning = true;
        }
        document.getElementById("animate-button").addEventListener("click", animate);

        const canvas = document.querySelector("canvas");
        const ctx = canvas.getContext("2d");

        const [width, height] = [canvas.width, canvas.height];

        canvas.addEventListener("mousemove", (ev) => {
            if (!ev.buttons) {
                return;
            }
            x_off.value = parseFloat(x_off.value) + ev.movementX / canvas.clientWidth * width;
            y_off.value = parseFloat(y_off.value) + ev.movementY / canvas.clientHeight * height;
        });

        let lastFrame = null;
        const drawLoop = (ts) => {
            ctx.resetTransform();
            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();

            const [x_off, y_off, scale] = [parseFloat(window.x_off.value), parseFloat(window.y_off.value),
                parseFloat(window.scale.value)];
            const border = {left: -x_off / scale, right: (-x_off + width) / scale,
                top: -y_off / scale, bottom: (-y_off + height) / scale};
            const drawingParams = {border, x_off, y_off, scale};

            ctx.translate(x_off, y_off);
            ctx.scale(scale, scale);
            ctx.lineWidth = 1.5 / scale;
            
            drawAxes(drawingParams);

            drawDiagram(sites, state, drawingParams);

            if (animationRunning === false) {
                lastFrame = null;
            } else {
                if (state.queue.length === 0) {
                    animationRunning = false;
                } else if (lastFrame === null) {
                    lastFrame = ts;
                } else {
                    const elapsed = ts - lastFrame;
                    lastFrame = ts;
    
                    const dYScanLine = elapsed / 1000 * 1;
                    yScanLine += dYScanLine;

                    while (state.queue.length > 0 && state.queue[0][0] < yScanLine) {
                        step(state);
                    }
                }
            }
           
            requestAnimationFrame(drawLoop);
        };

        const runAlgo = () => {
            yScanLine = -Infinity;
            animationRunning = false;

            sites = readSites();
            state = init(sites);
            while (state.queue.length > 0) {
                step(state);
            }
            diagram = state.diagram;
        };
        
        const initialSites = [{"x":5,"y":1.2}, {"x":9,"y":1}, {"x":3,"y":2}, {"x":7,"y":3}, {"x":4,"y":5}, {"x":5, "y":3}];
        for (const site of initialSites) {
            addSiteRow(site.x, site.y);
        }

        runAlgo();
        drawLoop();
    </script>
</body>
</html>