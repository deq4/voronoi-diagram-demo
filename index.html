<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="algorithm.js"></script>
    <title>Fortune algorithm demo</title>
</head>
<body>
    <canvas width="1000" height="1000"></canvas>
    <table>
        <thead>
            <tr>
                <th colspan="3">Sites</th>
            </tr>
            <tr>
                <th>x</th>
                <th>y</th>
            </tr>
        </thead>
        <tbody id="site-table-body">
        </tbody>
        <tfoot>
            <tr>
                <td><input id="site-add-x"></td>
                <td><input id="site-add-y"></td>
                <td><button id="site-add-button">+</button></td>
            </tr>
        </tfoot>
    </table>
    <div id="canvas-controls">
        <label>
            X offset
            <input type="number" id="x_off" step="50" value="10">
        </label>
        <label>
            Y offset
            <input type="number" id="y_off" step="50" value="10">
        </label>
        <label>
            Scale
            <input type="number" id="scale" step="0.2" value="1" min="0.2">
        </label>
    </div>

    <template id="site-template-row">
        <tr>
            <td></td>
            <td></td>
            <td><button>-</button></td>
        </tr>
    </template>

    <style>
        body {
            display: flex;
        }

        div, table {
            margin-left: 20px;
        }

        #canvas-controls {
            display: flex;
            flex-direction: column;
        }

        #canvas-controls label {
            margin: 10px;
        }

        canvas {
            width: 95vmin;
            height: 95vmin;
            align-self: center;
            border: 1px solid;
        }

        table {
            display: block;
        }

        td {
            text-align: right;
        }

        td input {
            width: 100px;
            text-align: right;
        }

        td button {
            width: 40px;
            border: 1px solid black;
        }
    </style>
    <script>
        function convertCoords(coords) {
            if (coords.y === -Infinity) return {x: coords.x * ALGO_SCALE, y: -y_off.value / scale};
            return {x: coords.x * ALGO_SCALE, y: coords.y * ALGO_SCALE};
        }

        function getRayBorderIntersection(startPoint, rayDirection, border) {
            let x, y;
            if (rayDirection.x !== 0) {
                x = rayDirection.x > 0 ? border.right : border.left;
                y = startPoint.y + (x - startPoint.x ) * rayDirection.y / rayDirection.x;
            } else {
                y = rayDirection.y > 0 ? border.bottom : border.top;
                x = startPoint.x;
            }
            return {x, y};
        }

        function drawAxes() {
            ctx.arc(0, 0, 2 / scale, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-x_off.value / scale, 0);
            ctx.lineTo((-x_off.value + width) / scale, 0);
            ctx.moveTo(0, -y_off.value / scale);
            ctx.lineTo(0, (-y_off.value + height) / scale);
            ctx.stroke();
        }

        function drawCircle(x, y, style) {
            ctx.save();
            ctx.fillStyle = style;
            ctx.beginPath();
            ctx.arc(x, y, 5 / scale, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }

        const addSiteButton = document.getElementById("site-add-button");
        const addSiteX = document.getElementById("site-add-x");
        const addSiteY = document.getElementById("site-add-y");
        const rowTemlate = document.getElementById("site-template-row");
        const sitesRows = document.getElementById("site-table-body");
        const removeSiteListener = ev => {
            const row = ev.target.parentElement.parentElement;
            row.remove();

            runAlgo();
        };
        const addSiteRow = (x, y) => {
            const row = rowTemlate.content.firstElementChild.cloneNode(true);
            row.children[0].innerText = x;
            row.children[1].innerText = y;
            row.children[2].firstElementChild.addEventListener("click", removeSiteListener);
            sitesRows.appendChild(row);
        };
        addSiteButton.addEventListener("click", ev => {
            addSiteRow(addSiteX.value, addSiteY.value);

            runAlgo();
        });

        const readSites = () => {
            let sites = [];
            for (const siteRow of sitesRows.children) {
                const x = parseFloat(siteRow.children[0].textContent);
                const y = parseFloat(siteRow.children[1].textContent);
                sites.push({x, y});
            }
            return sites;
        };

        let sites, diagram, state;

        const ALGO_SCALE = 50;

        const canvas = document.querySelector("canvas");
        const ctx = canvas.getContext("2d");

        const [width, height] = [canvas.width, canvas.height];
        ctx.font = '25px sans-serif';
        const baseTransform = ctx.getTransform();

        let scale;

        canvas.addEventListener("mousemove", (ev) => {
            if (!ev.buttons) {
                return;
            }
            x_off.value = parseFloat(x_off.value) + ev.movementX / canvas.clientWidth * width;
            y_off.value = parseFloat(y_off.value) +/*-*/ ev.movementY / canvas.clientHeight * height;
        });

        const drawLoop = () => {
            ctx.setTransform(baseTransform);
            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();

            scale = parseFloat(window.scale.value);
            ctx.translate(x_off.value, y_off.value);
            ctx.scale(scale, scale);
            ctx.lineWidth = 1.5 / scale;
            
            drawAxes();

            for (site of sites) {
                const coords = convertCoords(site);
                drawCircle(coords.x, coords.y, "black");
            }

            for (vertex of diagram.vertices) {
                const coords = convertCoords(vertex);
                drawCircle(coords.x, coords.y, "blue");
            }

            ctx.save();
            ctx.strokeStyle = "green";
            const border = {left: -x_off.value / scale, right: (-x_off.value + width) / scale,
                            top: -y_off.value / scale, bottom: (-y_off.value + height) / scale};
            for (const edge of diagram.edges) {
                for (const ray of edge) {
                    const startCoords = convertCoords(ray.rayStart);
                    let endCoords;
                    if (ray.segmentEnd) {
                        endCoords = convertCoords(ray.segmentEnd);
                    } else {
                        const rayDirection = getRayDirection(ray);
                        endCoords = getRayBorderIntersection(startCoords, rayDirection, border);
                    }

                    ctx.beginPath();
                    ctx.moveTo(startCoords.x, startCoords.y);
                    ctx.lineTo(endCoords.x, endCoords.y);
                    ctx.stroke();
                }
            }
            ctx.restore();
           
            requestAnimationFrame(drawLoop);
        };

        const runAlgo = () => {
            sites = readSites();
            state = init(sites);
            while (state.queue.length > 0) {
                step(state);
            }
            diagram = state.diagram;
        };
        
        const initialSites = [{"x":5,"y":1.2}, {"x":9,"y":1}, {"x":3,"y":2}, {"x":7,"y":3}, {"x":4,"y":5}, {"x":5, "y":3}];
        //const initialSites = [{x: 5, y: 1}, {x: 10, y: 4}];
        for (const site of initialSites) {
            addSiteRow(site.x, site.y);
        }

        runAlgo();
        drawLoop();
    </script>
</body>
</html>